# FP_vs_OOP
### Some personal thoughts between FP and OOP

---
## They‘re just patterns, not rules, let alone  truth.

从设计模式谈起  
        相信每一个以Java为母语的程序员都曾有过被设计模式折磨的痛苦经历，即使是不用Java开发甚至不怎么了解Java的程序员也或多或少了解或听说过“设计模式”——这个在OOP中被推向神坛的编程范式。可能每一个Java程序员都有过和我一样类似的经历，在面对这”大名鼎鼎“的23种设计模式时诚惶诚恐，再加上听闻诸多前辈强调设计模式多么重要的告诫更是唯唯诺诺，以为不懂设计模式就不算懂Java，甚至不懂设计模式就休想写出高质量代码，于是在写代码时畏手畏脚，生怕写出违反设计模式的劣质代码。在与别人聊天时也生怕暴露自己不理解某种设计模式，不然遭人耻笑。  
        就是在这样巨大的心理压力下，我曾好几次试图完全啃下设计模式，但遗憾的是这些尝试无一幸免。最根本的原因就在于在学习的过程中我其实明确地意识到这些设计模式不过是一些经验式的总结，遵循这些模式可能能帮助你写出漂亮而高效的代码，但它们不是像语法那样强制性的东西，更算不上代码的真谛。即使不按照设计模式来编写代码，无非就是代码质量可能比较差，但并不意味着无法运行。更何况每当我看设计模式的时候，可能遇到的情况无非三种，要不然是像工厂模式这样，让人觉得”这不是很自然而然的抽象过程吗，这也有值得单独学习的必要吗“的模式，要不然是像单例模式这种让人越琢磨越觉得有点别扭的模式，再或者就是那些更多的记也记不住，也不懂使用场景更不必谈为什么这么设计的设计模式了。  
        每次学习都无功而返的结局再加上被推上神坛的“23种设计模式“带给人的精神压力使得我对设计模式本身的怀疑转向了自身——为什么别人能总结出的东西我却看都看不懂，这不应该啊！终于，这种压抑许久的对设计模式权威的怀疑在最近得到了彻底释放。我不是要展开一场设计模式批斗会，相反我意识到要想在OOP范式下写出漂亮的代码，设计模式是绕不过去的。我只是想说代码本就灵活而美妙，不要被设计模式束缚住手脚。They‘re just patterns, not rules, let alone truth.  
        
        
int add(int x, int y){ return x + y; }  
        对于设计模式权威性怀疑的压抑从我开始接触第一个设计模式——工厂模式的时候就已经产生了，这种压抑的释放来自于我将注意力从尝试理解设计模式转移到思考程序的本质。所以程序的本质是什么？程序最根本的本质有两点，第一是过程和数据，或者更准确地说函数和值。程序所要描述或者说要解决的问题就是数据在经过一系列的函数过程后的结果。既然如此，我的出发点就是一个不能再普通的求和函数，输入两个数返回其和。有了函数和值，接下来就是程序本质的第二点——抽象。对于一个简单的求和函数还能进行什么抽象呢？当然可以，抽象的过程其实就是分析问题本质的过程，那么对于求和函数，可以看到它包含了两个操作数，和一个操作符。这两个操作数只能是int类型吗？显然不一定，它们还可以是float、double等等，甚至可以是自定义的类型——只要重载了加法运算符——于是乎我们有了泛型；这一个操作符只能是加法运算吗？显然也不一定，它还可以是减法、乘法、除法、取模、开方、甚至自定义的函数等等——于是乎我们又有了谓词逻辑。所以我们抽象的结果就是这样一个函数，它有两个输入，一个介于这两个输入之间的谓词，一个输出。为了简单起见，这里假设所有输入输出的数据类型都是一样的，用程序化的语言来表达即：  
       `类型A 两个同类型间的万能运算器（类型A a1, 类型A a2, 任意两个同类型间的算法 algorithm）{
            返回 algorithm(a1, a2);
       }`  
        举个不恰当的例子，你可以用这个“万能运算器”做一杯深水炸弹，只需这样调用这个函数：“两个同类型东西间的万能运算器（酒 啤酒， 酒 伏特加，把小杯伏特加扔进大杯啤酒中）”，这样这个程序就给你返回深水炸弹了。如果用C++来表达即我们要实现  
`template <typename T>  
T execute(T& a, T& b, ???) {  
    return ???;  
}`  
于是乎我们发现当我们尝试用编程语言去描述这个“万能运算器”时，我们碰到了一个很棘手的问题，即问号处到底该填什么。这个问题看似普通，但它却反映了FP与OOP世界观之间最根本的不同。  

FP VS OOP  
        终于，又到了这个老生常谈争论不休的编程德比。无数前辈对这个问题的讨论已经汗牛充栋，我就从前面这个例子出发，简单谈一谈这两个编程范式间世界观的差异——无关性能好坏、无关简洁与否、更无关正确性。  
        追本溯源，在一些信奉大道至简的C语言高手眼中，FP与OOP之间的争论可能没那么重要，没有什么问题是指针解决不了的，如果有，那就用指向指针的指针。以这个问题为例，execute函数的第三个参数其实就是一个函数指针，根本没什么大不了的。不得不承认，这种看待问题的方式就是站在计算机的角度来思考问题，而其解决也往往都是最高效的。但同样也需要承认，这种看问题的方式少了点语言学和逻辑学的趣味，而且更重要的是指针本身抽象能力弱的问题和其危险性，于是乎才有了FP与OOP的宗教之争。  
        那我们抛开指针，继续思考execute函数这第三个参数到底该怎么写。首先可以肯定的是这第三个参数也得是个函数一样的东西。如果是两数相加，那这第三个参数就负责把输入的两个数加起来；如果是制作深水炸弹，那这第三个参数就负责把小杯伏特加丢进大杯啤酒中去。也就是说这第三个参数是负责处理前两个输入的过程，那么它肯定是一个函数了。问题在于函数描述的是一个动态的过程，但这里又需要把它当成一个静态的值传进去，这办得到吗？如果能够做到，那函数与值之间的区别又是什么呢？  
        FP认为这当然可以做到，函数为什么不可以是值呢？函数可以被调用，可以用来计算，但同时函数本身其实也是一个用来描述计算过程的东西，所以函数也应该有它自己的类型。于是我们就有了几乎无所不能的first-class function，以及各种复杂而强大的类型系统。确认了这一点，我们就可以以函数式的方式完成我们的函数原型，即  
`template <typename T>  
T execute(T& a, T& b, function<T(T, T)> func) {  
    return func(a, b);  
}`  
也就是说第三个参数我们传进来一个谓词函数，这个函数的作用是接收两个和execute前两个参数一样类型的参数，被调用后返回一个这个类型的数据，所以返回语句我们直接调用这个函数就可以了。不难看出，函数式编程关注的是对问题本身的描述和对解决问题过程的抽象，更形象地说，函数式编程关注的是func而不是func()。当被问及问题到底是怎么被解决的时，FP会告诉你你尽只管描述和抽象，到时候开闸放水自然水到渠成，这也就是所谓的惰性求值。惰性求值在FP中是自然而然的，数据只有流动到被调函数的地方时被调函数才会去计算。就好比一台压面机，在没有面团输入的时候他就是一个函数类型的实体（function<T(T, T)> func），当有面团来的时候它才会执行计算（func(a, b)）。这也说明了为什么FP支持者那么强调代码的正确性，而将赋值语句看作是洪水猛兽般的怪物。一旦对问题的描述与抽象工作完成，那么无论何时何地，一组确定的输入必然会得到一组确定的输出。就好比当我们完成了一系列对炒菜过程的抽象后，凡是输入土豆一定可以得到一盘美味的土豆丝，但是一旦在其中加入人为的赋值操作，整个过程就变得不确定了，就好像在炒菜过程中加入了一勺芥末或者一撮灰尘一样。  
        所以那些最最狂热的Haskell拥护者不仅视赋值为洪水猛兽，他们甚至不在乎输入输出——输入输出仅仅只是验证程序正确性的工具罢了。真正有趣且有意义的就是如何描述问题以及如何对其抽象。它们不会在乎薛定谔的猫到底是死是活，也不会在意粒子在某一时刻到底在哪里、方向朝哪速度如何，他们关心的就是波粒二象性本身。  
        我无意做FP与OOP孰优孰劣的讨论，每个人尽可以根据不同场景和自己的编程喜好来写代码。既然如此，讨论完FP，自然少不了OOP。回到最开始的问题，如果我们没有first-class function，函数不能作为值进行传递，那么execute函数的这第三个参数又该怎么写呢？在OOP范式下，这个问题再经典也再简单不过了——当然是让对象帮我们做啦。我们只需要传入一个对象，只要这个对象实现了加工两个同类型参数的方法，那么我们在返回时只需要用这个对象调用它的这个方法就可以了，所以函数原型就变成了类似这样的形式：  
`template <typename T>  
T execute(T& a, T& b, Relatable* m) {  
    return m->relate(a, b);  
}`
其中Relatable是一个接口，只要其实现类重写了relate()虚函数就可以将这个实现类的实例化对象传入execute中。然而理想是美好的，现实却是骨感的，编译器在我设计Relatable接口时就好像一个刻薄的长者，等着代码水平青涩的我掉进他早就布置好的陷阱中。由于模板的存在，接口中纯虚函数不得不写成virtual template<T> T relation(T t1, T t2) = 0;然而virtual与template间的矛盾使得它们不能同时修饰一个函数，毕竟编译期无法规划一张无限大的虚拟表。火药味在这场即将发生的我与编译器之间的厮杀前越来越浓……但这场厮杀还未开始就以我的胜利而告终——毕竟这也不是多难的问题。只需将模板定义在类上把接口变成模板抽象类就可以了。  
        到这里我们发现其实程序已经变得非常像Java了。最大的不同之处就在于execute的定义和调用方式。在Java中，函数或者说方法是没有办法被定义在类外的——这也是为什么很多人都觉得Java写多了会有一种窒息的感觉，因为一切都被class包裹起来了，甚至main方法——所以execute函数到了Java这里就可以将面向对象的思想贯彻的更为彻底。之前execute函数中第三个参数填什么的问题在Java这也迎刃而解——我们根本就不需要这第三个参数！execute的执行在C++中是由我们手动调用的，但在Java中，我们需要创建一个类，再由这个类的对象调用方法，既然如此，我们何不将这第三个参数所要干的活直接以成员方法的形式写进要创建的这个类中呢？于是在Java中我们的实现目标就变为了：  
`interface Relatable {  
       public <T> T relate(T t1, T t2, Class<T> type);  
}`  
由于Java的泛型擦除，我们无法在重写接口实现类的抽象方法时直接return new XXX()，所以这里的接口中的relate方法还需要第三个类对象参数，以便通过反射的方式在实现类中完成对象的构造。
        写到这里我必须为自己曾经的轻浮道歉。似乎每个Java程序员为了彰显自己对代码的理解都会批评自己使用的这门具有厚重历史的语言，就好像每个古典音乐爱好者都可能为了彰显自己对音乐的品味而批评卡拉扬一样，曾经我也觉得Java沉重，拘束，令人窒息，但当真正领悟那被重复烂了的五个字——对象调方法的时候，我才意识到这种将一切函数封装进类中的做法也是有道理的。而那23种设计模式正是面向对象思想下的产物，它们要不然是这种思想下经验式的编码技巧，要不然是在为完全面向对象所付出的代价买单。  

λ-calculus  
        重新回顾我们所实现的不同版本的execute函数，抛开C++ std::function的各种历史包袱进行一个小总结。首先我们实现了一个函数式版的execute，在这个方法中我们将第三个参数设为function<T(T, T)> func，实际上这个参数就是一个谓词，既然是谓词，那我们自然可以用λ函数改写成类似  
`[](T x, T y) -> {T t = T::relate(x, y); return t;}`  
的形式（虽然std::function其实也是对各种包括lambada表达式、仿函数、函数指针等callable的统一）。这时我们发现我们想要实现的这个execute函数实在是多此一举，因为这个λ函数已经帮我们搞定了我们想要的一切——与其将这个λ函数作为参数传给execute再调用execute，为何不干脆  
`auto func = [](T x, T y) -> {T t = T::relate(x, y); return t;}`  
然后直接调用这个func呢——我们其实是在手动实现λ表达式已经提供给我们的东西了。  
        再来看之前C++实现的第二版execute，我们将第三个参数设为Relatable* m，实际上就是用一个对象代替了谓词函数，只不过要求这个对象必须能够调用接口中被重写的抽象方法。这时我们恍然大悟，其实这个Relatable就是Callable，而原来所谓的Callable本质上就是用一个对象去代替谓词函数，即也就是面向对象思想下的函数式编程！重新审视这第二版的execute我们终于明白，这就是一个面向对象面了一半的产物，一个夹在函数式与面向对象间的产物，一个用面向对象的手段去模仿函数式编程的产物。而在第三版中，execute的身影已经不见了，我们用完全面向对象的方式将其隐藏在了封装的接口中。  
        在经历了这一系列从FP到OOP的过渡后，我们再来看λ演算，不得不感叹丘奇的天才。一切的一切竟都可以从简单的λx出发，以至无穷。函数式的表现力，它的简洁与优雅实在令人印象深刻。

关于计算与语言的一些小思考  
        有人说“计算机是数学家一次思考失败的产物”，这句话放到计算机科学高度发展的今天来看或许恰恰说反了——从元数学的角度来看，数学是计算机一个完美的遗憾似乎更为贴切。   
        同样的，还有人说程序是对现实世界的模仿，可能这也是一种本末倒置——程序是对现实世界的高度抽象，它反映了现实世界的本质。  
